### 连接数据库
### 导入库
```.py
import pandas as pd#pandas是强大的数据科学库
from sqlalchemy import create_engine#编程都需要ORM ，这个是python用的最广泛的数据连接方式
```
**pandas**
pandas是一个强大的数据科学数据库，里面包含许多科学方法，其中主要包含两个数据类型Series和DataFrame，其中series表示一维数据，与numpy的array类似。DataFrame表示二维的表格数据结构。一般会表示成二维结构。
**sqlalchemy** 
SQLalchemy是python中最著名的ORM。其中ORM是object relational mapping,这个就像是关系映射所要使用的包，这里我理解成SSH中的数据驱动。
```.py
engine = create_engine('mysql+pymysql://root:mysql@127.0.0.1:3307/shuju?charset=utf8')
sql = pd.read_sql('all_gzdata', engine, chunksize = 10000)
```
* 其中create_engine表示建立连接，mysql+pymysql:表示是python和MySQL的连接，root表示数据库的名称，MySQL表示数据库的地址，然后后面表示数据库的地址3307表示数据库的端口号，shuju是数据库的名称，后面表示编码。通过这个解释以后可以对相应的参数进行变换即可。
* pd.read_sql表示读取数据库的数据，规格pd.read_sql（表名，地址，每次读取的数据值）。表示去地址为engine的数据表为all_gzdata的表中读取 数据，分块读取，每次读取10000条记录。这时SQL相当于一个容器，并没有真正的读取数据。
### 逐块读取数据
```.py
counts = [ i['fullURLId'].value_counts() for i in sql] #逐块统计这时是一个dataframe
```
表示逐块统计fullURLId。value_counts()这个方法会统计个数，就是像统计每个类型出现的个数并按照左右显示出来。这里是对fullURLId进行统计。按照sql进行逐块统计，每次统计10000条记录，这时把counts数出来展示如下，这里列出一部分，其中会显示相关的列的种类和每个的数量。最后会显示统计的名字和数据类型。
```.py
D:\Program\Anaconda\python.exe E:/text/text.py
[101003     4762
1999001    2389
107001     2143
301001      177
101002      166
102002      163
101001       51
106001       37
103003       26
101009       18
102001       15
103002       15
102005       10
101008        8
102003        6
102008        4
101007        3
102009        2
102006        2
101005        1
101006        1
101004        1
Name: fullURLId, dtype: int64, 101003     4832
107001     2306
1999001    2269
301001      154
102002      151
101002      134
101001       53
106001       40
102001       14
103003       11
102003        8
101009        6
103002        5
102005        4
101008        3
101006        3
102006        3
102007        2
102004        1
101004        1
Name: fullURLId, dtype: int64, 101003     4755
107001     2314
1999001    2104
102002      239
301001      184
101002      163
101001       64
106001       52
102001       33
102003       24
103003       23
102005       12
101009       11
102004        8
102008        4
101006        4
101008        2
102006        2
101007        1
101005        1
Name: fullURLId, dtype: int64, 101003     4462
107001     2426
1999001    2422
102002      202
301001      192
101001       90
101002       58
106001       56
103003       32
102003       18
102001       12
102008        7
102005        6
101009        6
101008        3
102009        2
103002        2
102007        2
101006        1
101004        1
Name: fullURLId, dtype: int64,
```
其中每一个表示10000条，对这10000条按照fullURLId按照不同进行统计。然后依次输出出来
### 合并统计结果
```.py
counts = pd.concat(counts).groupby(level=0).sum() 
```
其中pd.concat(counts)表示合并那么多的分统计counts，groupby(level=0)这个表示分组，后面表示求和，展示结果如下。相当于把数据库中的数据进行分组，然后进行求和
```.py
101002       7776
101003     396612
101004        125
101005         63
101006        107
101007        147
101008        378
101009        854
102001       2129
102002      12021
102003       1235
102004        361
102005        271
102006        184
102007        538
102008        404
102009        214
103002        189
103003       1526
106001       3957
107001     182900
1999001    201426
301001      18430
Name: fullURLId, dtype: int64
```
### 重新设置index
```.py
counts = counts.reset_index() #重新设置index，将原来的index作为counts的一列。这个相当于重新设置列
展示结果显示如下
0    101001       5603
1    101002       7776
2    101003     396612
3    101004        125
4    101005         63
5    101006        107
6    101007        147
7    101008        378
8    101009        854
9    102001       2129
10   102002      12021
11   102003       1235
12   102004        361
13   102005        271
14   102006        184
15   102007        538
16   102008        404
17   102009        214
18   103002        189
19   103003       1526
20   106001       3957
21   107001     182900
22  1999001     201426
23   301001      18430
```
### 重新设置列名
重新设置列名，利用counts.columns=['','']进行设置
```.py
counts.columns = ['index', 'num'] 
      index     num
0    101001    5603
1    101002    7776
2    101003  396612
3    101004     125
4    101005      63
5    101006     107
6    101007     147
7    101008     378
8    101009     854
9    102001    2129
10   102002   12021
11   102003    1235
12   102004     361
13   102005     271
14   102006     184
15   102007     538
16   102008     404
17   102009     214
18   103002     189
19   103003    1526
20   106001    3957
21   107001  182900
22  1999001  201426
23   301001   18430
```
### 提取前三个
这个可以新出一列，列名为‘type’，counts['index']按照index中的进行统计，后面str.extract表示提取相关数，这里表示提取前三个字符。
```.py
counts['type'] = counts['index'].str.extract('(\d{3})') #提取前三个数字作为类别id，这里转换成可以统计的数据，用到str.extract，表示提取参考https://jingyan.baidu.com/article/e75aca855a0103142edac63c.html
结果展示：
     index     num type
0    101001    5603  101
1    101002    7776  101
2    101003  396612  101
3    101004     125  101
4    101005      63  101
5    101006     107  101
6    101007     147  101
7    101008     378  101
8    101009     854  101
9    102001    2129  102
10   102002   12021  102
11   102003    1235  102
12   102004     361  102
13   102005     271  102
14   102006     184  102
15   102007     538  102
16   102008     404  102
17   102009     214  102
18   103002     189  103
19   103003    1526  103
20   106001    3957  106
21   107001  182900  107
22  1999001  201426  199
23   301001   18430  301
```
### 按类别合并
提取完了后会都显示出来，我们所需要的就是type和num，但是上面结果还有其他的，所以要去除。所以只要type和num这两行，然后按照type进行分组求和与上一个一样
```.py
counts_ = counts[['type', 'num']].groupby('type').sum() #按类别合并     
type   num     
101   411665
102    17357
103     1715
106     3957
107   182900
199   201426
301    18430
```
### 降序排列
```.py
counts_.sort_values('num', ascending = False) #降序排列

```





